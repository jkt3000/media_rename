#!/usr/bin/env ruby

$LOAD_PATH.unshift File.expand_path(File.join(File.dirname(__FILE__), "../lib"))

require "bundler/setup"
require "media_rename"
require 'thor'
require 'io/console'

class MediaRenameCLI < Thor


  desc "plex <path>", "Renames media files from plexDB"
  method_option :preview,
                type: :boolean,
                default: false,
                desc: "Dry run - don't actually make changes"
  method_option :plex_library,
                type: :string,
                aliases: 'p',
                desc: "Plex Library to search against"
  method_option :plex_host, 
                type: :string,
                desc: "Plex Server IP address" 
  method_option :plex_port, 
                type: :string,
                desc: "Plex Server port" 
  method_option :plex_token, 
                type: :string,
                desc: "Plex token" 
  method_option :verbose,
                type: :boolean,
                aliases: 'v',
                default: false,
                desc: "Verbose"
  method_option :target_path,
                type: :string,
                aliases: 't',
                desc: "Target path"

  def plex(path)
    p options
    init_plex(options)
    set_log_level(options[:verbose])
    params = options.inject({}){|memo,(k,v)| memo[k.to_sym] = v; memo}
    renamer = MediaRename::PlexRenamer.new(path, params)
    renamer.run
  end


  desc "rename_colon <path>", "Fixes media files that have colon in them"
  method_option :preview,
                type: :boolean,
                default: false,
                desc: "Dry run - don't actually make changes"
  method_option :plex_library,
                type: :string,
                aliases: 'p',
                desc: "Plex Library to search against"
  method_option :plex_host, 
                type: :string,
                desc: "Plex Server IP address" 
  method_option :plex_port, 
                type: :string,
                desc: "Plex Server port" 
  method_option :plex_token, 
                type: :string,
                desc: "Plex token" 
  method_option :verbose,
                type: :boolean,
                aliases: 'v',
                default: false,
                desc: "Verbose"
  method_option :target_path,
                type: :string,
                aliases: 't',
                desc: "Target path"

  def rename_colon(path)
    p options
    set_log_level(options[:verbose])
    params = options.inject({}){|memo,(k,v)| memo[k.to_sym] = v; memo}
    folders, junk =  MediaRename::Utils.folders(path).partition {|f| f.include?(':')}
    folders.sort.each do |folder|
      files = MediaRename::Utils.files(folder)
      actions = files.map do |f|
        "mv [#{f}]\n=> [#{f.gsub(":", "-")}]"
      end.join("\n")
      msg = "Folder [#{folder}]\n" + actions 

      if confirmation(msg, {confirmation_required: true})
        files.each do |file|
          new_dest = file.gsub(":", "-")
          MediaRename::Utils.mv(file, new_dest, params)
        end
        MediaRename::Utils.rm_path(folder, params)        
      end
    end
  end
  

  desc "validate <path>", "compare all directories and compare vs Plex"
  method_option :preview,
                type: :boolean,
                default: false,
                desc: "Dry run - don't actually make changes"
  method_option :plex_library,
                type: :string,
                aliases: 'p',
                desc: "Plex Library to search against"
  method_option :plex_host, 
                type: :string,
                desc: "Plex Server IP address" 
  method_option :plex_port, 
                type: :string,
                desc: "Plex Server port" 
  method_option :plex_token, 
                type: :string,
                desc: "Plex token" 
  method_option :verbose,
                type: :boolean,
                aliases: 'v',
                default: false,
                desc: "Verbose"
  method_option :target_path,
                type: :string,
                aliases: 't',
                desc: "Target path"

  def validate(path)
    p options
    init_plex(options)
    set_log_level(options[:verbose])
    params = options.inject({}){|memo,(k,v)| memo[k.to_sym] = v; memo}
    renamer = MediaRename::PlexRenamer.new(path, params)
    folders = MediaRename::Utils.folders(path)
    folders.sort.each do |folder|
      medias = renamer.find_plex_medias(folder)
      files = MediaRename::Utils.media_files(folder)
      if files.empty?
        puts "[#{folder}] has no media files"
        anyfiles = MediaRename::Utils.files(folder)
        anyfolders = MediaRename::Utils.folders(folder)
        puts "all files: #{anyfiles.inspect} #{anyfolders.inspect}"
        if confirmation("Delete?", {confirmation_required: true})
          MediaRename::Utils.rm_path(folder)
        end
      end

      files.each do |file|
        media = medias.find {|m| m[:file] == file }
        if media
          expected = renamer.target_name(media[:media])
          if expected != file
            puts "Needs renaming:\n == #{file} \n => #{expected}"
            if confirmation('continue?', {confirmation_required: true})
              renamer.create_entry(file, media[:media])
            end
          end
        else
          puts '-----------------'
        end
      end
    end
  end


  private

  def confirmation(msg, options)
    return true unless options[:confirmation_required] == true
    puts "> #{msg}?\nCONFIRM? [Y/n/q]"
    value = STDIN.getch
    case value
    when 'q', "Q", "\u0003"
      puts
      abort("Quitting...")
    when 'y', "Y", "\r", "\n"
      puts
      true
    else
      false
    end
  end

  def set_log_level(verbose)
    MediaRename.logger.level = verbose ? :debug : :info
  end

  def init_plex(options)
    Plex.configure do |config|
      if host = options.fetch(:plex_host, nil)
        config[:host] = host
      end
      if port = options.fetch(:plex_port, nil)
        config[:port] = port
      end
      if token = options.fetch(:plex_token, nil)
        config[:token] = token
      end
    end
  end
end


MediaRenameCLI.start